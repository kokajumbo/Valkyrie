// Сервис Региональные ставки налогов

#Область ПрограммныйИнтерфейс

// Возвращает информацию сервиса о региональных особенностях применения УСН.
//
// Параметры:
//  ПараметрыПолучения - Структура - параметры для запроса информации в сервисе
//  	* КодРегиона - Строка - код субъекта РФ
//  	* КодОКВЭД - Строка - код вида деятельности по классификатору ОКВЭД (ред.2)
//  	* ЭтоЮрЛицо - Булево - получать информацию для организации-юр.лица или для предпринимателя
//  	* ПрименяетсяУСНДоходы - Булево - получать информацию для системы налогообложения УСН (доходы)
//  	* ПрименяетсяУСНДоходыРасходы - Булево - получать информацию для системы налогообложения УСН (доходы - расходы)
// 
// Возвращаемое значение:
//   - Структура
//		* КодСостояния - Число - код состояния из ответа сервиса
//		* Ответ - Структура - информация о региональных особенностях применения УСН
//		* ОписаниеОшибки - Строка - ошибка, возникшая при вызове серсиса
//
Функция ИнформацияУСНВВашемРегионе(ПараметрыПолучения) Экспорт
	
	АдресРесурса = АдресИнформацияУСНВВашемРегионе()
		+ СтрокаПараметровЗапросаКСервису(ПараметрыПолучения, 
			СоответствиеПараметровИнформацияУСНВВашемРегионе());
		
	Возврат ИнформацияСервиса(АдресРесурса);
	
КонецФункции

// Получает краткую информацию о региональных особенностях применения УСН, 
// помещает ее как форматированную строку во временное хранилище.
//
// Параметры:
//  ПараметрыПолучения - Структура - параметры для запроса информации в сервисе
//  	* КодРегиона - Строка - код субъекта РФ
//  	* ЭтоЮрЛицо - Булево - получать информацию для юридического лица или для предпринимателя
//  	* ПрименяетсяУСНДоходы - Булево - получать информацию для системы налогообложения УСН (доходы)
//  	* ПрименяетсяУСНДоходыРасходы - Булево - получать информацию для системы налогообложения УСН (доходы - расходы)
//  АдресХранилища - Строка	- адрес временного хранилища
//
Процедура ПолучитьЗаголовокДекорацииУСНВВашемРегионе(ПараметрыПолучения, АдресХранилища) Экспорт
	
	Результат = ЗаголовокДекорацииУСНВВашемРегионе(ПараметрыПолучения);
	
	ПоместитьВоВременноеХранилище(Результат, АдресХранилища);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает описание токена
//
// Возвращаемое значение:
//   Структура - структура соответствуют описанию JWT-токена
//
Функция СвойстваВременногоТокена() Экспорт
	
	Свойства = СвойстваТокена(ВременныйТокен());
	
	Возврат Свойства;
	
КонецФункции

// Процедура обновления временного токена фоновым заданием.
// Сохраняет токен в безопасном хранилище данных и возвращает его свойства.
//
// Параметры:
//   Параметры - не используется
//   АдресХранилища - Строка - адрес временного хранилища, в которое будет помещены свойства полученного временного токена
//
//
Процедура ОбновитьВременныйТокен(Параметры, АдресХранилища) Экспорт
	Перем СообщениеОбОшибке;
	
	ВременныйТокен = НовыйВременныйТокен(Ложь, СообщениеОбОшибке);
	Если ЗначениеЗаполнено(ВременныйТокен) Тогда
		Свойства = СвойстваТокена(ВременныйТокен);
	Иначе
		Свойства = Новый Структура("Ошибка", СообщениеОбОшибке);
	КонецЕсли;
	
	ПоместитьВоВременноеХранилище(Свойства, АдресХранилища);
	
КонецПроцедуры

// Удаляет временный токен
//
Функция УдалитьВременныйТокен(СообщениеОбОшибке = "") Экспорт
	
	КлючЗаписиБезопасногоХранилища = РегистрыСведений.БезопасноеХранилищеДанныхОбщее.НовыйКлючЗаписи(ВладелецДанныхБезопасногоХранилища());
	Если Не ЗаблокироватьВременныйТокенДляОбновления(КлючЗаписиБезопасногоХранилища) Тогда
		СообщениеОбОшибке = НСтр("ru = 'Не удалось заблокировать временный токен для изменения'");
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	РегистрыСведений.БезопасноеХранилищеДанныхОбщее.Удалить(ВладелецДанныхБезопасногоХранилища(), КлючВременногоТокена());
	УстановитьПривилегированныйРежим(Ложь);
	
	РазблокироватьВременныйТокен(КлючЗаписиБезопасногоХранилища);
	
	Возврат Истина;
	
КонецФункции

Функция ВладелецДанныхБезопасногоХранилища() Экспорт
	
	Возврат "БухгалтерияПредприятия.РегиональныеСтавкиНалогов";
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЗаголовокДекорацииУСНВВашемРегионе(ПараметрыПолучения)
	
	Если ПустаяСтрока(ПараметрыПолучения.КодРегиона) Тогда
		Возврат НСтр("ru='Не заполнен регион регистрации организации'");
	КонецЕсли;
	
	АдресРесурса = АдресЗаголовокДекорацииУСНВВашемРегионе()
		+ СтрокаПараметровЗапросаКСервису(ПараметрыПолучения,
			СоответствиеПараметровЗаголовокДекорацииУСНВВашемРегионе());
		
	ОтветСервиса = ИнформацияСервиса(АдресРесурса);
	Если НЕ ПустаяСтрока(ОтветСервиса.ОписаниеОшибки) Тогда
		Возврат ОтветСервиса.ОписаниеОшибки;
	КонецЕсли;
	
	ЧастиСтроки = Новый Массив;
	ЧастиСтроки.Добавить(ОтветСервиса.Ответ);
	
	ЧастиСтроки.Добавить(Символы.ПС);
	ЧастиСтроки.Добавить(Новый ФорматированнаяСтрока(НСтр("ru='Подробнее'"), , , , "УСНВВашемРегионе"));
	
	Возврат Новый ФорматированнаяСтрока(ЧастиСтроки);
	
КонецФункции

#Область РаботаССервисом

Функция ИнформацияСервиса(АдресРесурса)

	Результат = НовыйРезультатЗапросаСервис();
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьСервисРегиональныеСтавкиНалогов") Тогда
		Результат.ОписаниеОшибки = НСтр("ru='Сервис не используется'");
		Возврат Результат;
	КонецЕсли;
	
	СтруктураАдреса = ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресСервиса());
	
	Если Не СервисДоступен(СтруктураАдреса) Тогда
		Результат.ОписаниеОшибки = НСтр("ru='Сервис временно недоступен'");
		Возврат Результат;
	КонецЕсли;
	
	Соединение = СоединениеССервисом(СтруктураАдреса, ТаймаутСоединения());
	Запрос = ЗапросКСервису(СтруктураАдреса, АдресРесурса);
	
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		ЗаписатьОшибкуСервисаВЖурналРегистрации(ТекстОшибки);
		Результат.ОписаниеОшибки = НСтр("ru='Не удалось получить данные сервиса.'");
		Возврат Результат;
	КонецПопытки;
	
	Результат.КодСостояния = Ответ.КодСостояния;
	ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
	Если Ответ.КодСостояния = 200 Тогда
		Результат.Ответ = ЗначениеИзJSON(ТекстОтвета, Ложь);
		Возврат Результат;
	Иначе
		ТекстОшибки = СтрШаблон("%1; %2", Ответ.КодСостояния, ТекстОтвета);
		ЗаписатьОшибкуСервисаВЖурналРегистрации(ТекстОшибки);
		Результат.ОписаниеОшибки = СтрШаблон(НСтр("ru='Не удалось получить данные сервиса: код ошибки %1'"), Ответ.КодСостояния);
		Возврат Результат;
	КонецЕсли;
	
КонецФункции

Функция СоединениеССервисом(СтруктураАдреса, Таймаут, Пользователь = Неопределено, Пароль = Неопределено)

	Прокси = ПолучениеФайловИзИнтернетаКлиентСервер.ПолучитьПрокси(СтруктураАдреса.Схема);
	Соединение = Новый HTTPСоединение(
		СтруктураАдреса.Хост,
		СтруктураАдреса.Порт,
		Пользователь,
		Пароль,
		Прокси,
		Таймаут,
		?(СтруктураАдреса.Схема = "http", Неопределено, Новый ЗащищенноеСоединениеOpenSSL));
		
	Возврат Соединение;

КонецФункции

Функция ТаймаутСоединения()
	
	Возврат 60;
	
КонецФункции

Функция СервисДоступен(СтруктураАдреса)

	Соединение = СоединениеССервисом(СтруктураАдреса, 7);
	Запрос = ЗапросКСервису(СтруктураАдреса, АдресPing());
	Попытка
		Ответ = Соединение.Получить(Запрос);
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		ЗаписатьОшибкуСервисаВЖурналРегистрации(ТекстОшибки);
		Возврат Ложь;
	КонецПопытки;
	Если Ответ.КодСостояния <> 200 Тогда
		ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
		ТекстОшибки = "" + Ответ.КодСостояния + "; " + ТекстОтвета;
		ЗаписатьОшибкуСервисаВЖурналРегистрации(ТекстОшибки);
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции

Функция ЗапросКСервису(СтруктураАдреса, АдресРесурса)

	Запрос = Новый HTTPЗапрос;
	Запрос.АдресРесурса = ?(ПустаяСтрока(СтруктураАдреса.ПутьНаСервере), 
		"", 
		"/" + СтруктураАдреса.ПутьНаСервере) + АдресРесурса;
	Запрос.Заголовки.Вставить("Content-Type", "application/json");
	Запрос.Заголовки.Вставить("accept", "application/json");
	
	Если ИспользуетсяАвторизацияПоВременномуТокену() Тогда
		Токен = ВременныйТокен();
		Если ЗначениеЗаполнено(Токен) Тогда
			Запрос.Заголовки.Вставить("Authorization", СтрШаблон("Bearer %1", Токен));
		КонецЕсли;
	КонецЕсли;
	
	Возврат Запрос;

КонецФункции

Функция НовыйРезультатЗапросаСервис()

	Результат = Новый Структура;
	Результат.Вставить("КодСостояния", 0);
	Результат.Вставить("Ответ", "");
	Результат.Вставить("ОписаниеОшибки", "");
	Возврат Результат;

КонецФункции

Процедура ЗаписатьОшибкуСервисаВЖурналРегистрации(ТекстОшибки)
	
	ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрацииСервис(),
		УровеньЖурналаРегистрации.Ошибка,
		,
		,
		ТекстОшибки);
	
КонецПроцедуры

Функция ИмяСобытияЖурналаРегистрацииСервис()
	
	Результат = НСтр("ru = 'Региональные ставки налогов'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка());
	Возврат Результат;
	
КонецФункции

Функция АдресСервиса()
	
	Возврат Константы.АдресСервисаРегиональныеСтавкиНалогов.Получить();
	
КонецФункции

Функция АдресPing()
	
	Возврат "/ping";
	
КонецФункции

Функция АдресИнформацияУСНВВашемРегионе()
	
	Возврат "/rates";
	
КонецФункции

Функция СоответствиеПараметровИнформацияУСНВВашемРегионе()
	
	Результат = Новый Соответствие;
	Результат.Вставить("region", "КодРегиона");
	Результат.Вставить("okved", "КодОКВЭД");
	Результат.Вставить("isCompany", "ЭтоЮрЛицо");
	Результат.Вставить("usnD", "ПрименяетсяУСНДоходы");
	Результат.Вставить("usnDR", "ПрименяетсяУСНДоходыРасходы");
	Возврат Результат;
	
КонецФункции

Функция АдресЗаголовокДекорацииУСНВВашемРегионе()
	
	Возврат "/description";
	
КонецФункции

Функция СоответствиеПараметровЗаголовокДекорацииУСНВВашемРегионе()
	
	Результат = Новый Соответствие;
	Результат.Вставить("region", "КодРегиона");
	Результат.Вставить("isCompany", "ЭтоЮрЛицо");
	Результат.Вставить("usnD", "ПрименяетсяУСНДоходы");
	Результат.Вставить("usnDR", "ПрименяетсяУСНДоходыРасходы");
	Возврат Результат;
	
КонецФункции

Функция СтрокаПараметровЗапросаКСервису(ВходныеПараметры, СоответствиеПараметров)
	
	ПараметрыЗапроса = Новый Массив;
	Для каждого СоответствиеПараметра Из СоответствиеПараметров Цикл
		ЗначениеПараметра = ВходныеПараметры[СоответствиеПараметра.Значение];
		Если ЗначениеЗаполнено(ЗначениеПараметра) Тогда
			ПараметрыЗапроса.Добавить(СоответствиеПараметра.Ключ + "=" + XMLСтрока(ЗначениеПараметра));
		КонецЕсли;
	КонецЦикла;
	
	Возврат ?(ПараметрыЗапроса.Количество() > 0,
		"?" + СтрСоединить(ПараметрыЗапроса, "&"),
		"");
	
КонецФункции

#КонецОбласти

#Область РаботаСJSON

Функция ЗначениеИзJSON(ТекстJSON, ВСоответствие, СвойстваТипаДата = Неопределено)
	
	ЧтениеJSON = Новый ЧтениеJSON;
	Попытка
		ЧтениеJSON.УстановитьСтроку(ТекстJSON);
		Значение = ПрочитатьJSON(ЧтениеJSON, ВСоответствие, СвойстваТипаДата);
	Исключение
		Значение = Неопределено;
	КонецПопытки;
	ЧтениеJSON.Закрыть();
	
	Возврат Значение;
	
КонецФункции

#КонецОбласти

#Область Авторизация

Функция ИспользуетсяАвторизацияПоВременномуТокену()
	
	УчетнаяЗапись = УчетнаяЗаписьКлиента();
	Возврат УчетнаяЗапись <> Неопределено;
	
КонецФункции

// Возвращает временный токен авторизации, обновляя при необходимости
//
// Параметры:
//   СообщениеОбОшибке - Строка - Исходящий параметр
//
// Возвращаемое значение:
//  Строка, Неопределено
//
Функция ВременныйТокен(СообщениеОбОшибке = "")
	
	УстановитьПривилегированныйРежим(Истина);
	ВременныйТокен = РегистрыСведений.БезопасноеХранилищеДанныхОбщее.Прочитать(
		ВладелецДанныхБезопасногоХранилища(),
		КлючВременногоТокена());
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Не ТокенДейсвует(ВременныйТокен, ТаймаутСоединения()) Тогда
		ВременныйТокен = НовыйВременныйТокен(Истина, СообщениеОбОшибке);
	КонецЕсли;
	
	Возврат ВременныйТокен;
	
КонецФункции

// Запрашивает и возвращает новый временный токен авторизации
//
// Параметры:
//   ПроверятьСрокДействия - Булево - Ложь, если необходимо обновить токен принудительно без проверки срока действия
//   СообщениеОбОшибке - Строка - Исходящий параметр
//
// Возвращаемое значение:
//  Строка, Неопределено
//
Функция НовыйВременныйТокен(ПроверятьСрокДействия = Истина, СообщениеОбОшибке = "")
	Перем ВременныйТокен;
	
	УчетнаяЗапись = УчетнаяЗаписьКлиента();
	Если УчетнаяЗапись = Неопределено Тогда
		ВызватьИсключение НСтр("ru = 'Не задана учетная запись пользователя сервиса. Обратитесь к администратору сервиса.'");
		Возврат Неопределено;
	КонецЕсли;
	
	КлючЗаписиБезопасногоХранилища = РегистрыСведений.БезопасноеХранилищеДанныхОбщее.НовыйКлючЗаписи(
		ВладелецДанныхБезопасногоХранилища());
	Если Не ЗаблокироватьВременныйТокенДляОбновления(КлючЗаписиБезопасногоХранилища) Тогда
		СообщениеОбОшибке = НСтр("ru = 'Не удалось заблокировать временный токен для изменения. Повторите попытку позже.'");
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПроверятьСрокДействия Тогда
		
		// Блокировка установленя, проверим срок действия на случай, если другой сенс уже обновил токен.
		УстановитьПривилегированныйРежим(Истина);
		ВременныйТокен = РегистрыСведений.БезопасноеХранилищеДанныхОбщее.Прочитать(
			ВладелецДанныхБезопасногоХранилища(),
			КлючВременногоТокена());
		УстановитьПривилегированныйРежим(Ложь);
		
		ОбновитьТокен = Не ТокенДейсвует(ВременныйТокен, ТаймаутСоединения());
		
	Иначе
		ОбновитьТокен = Истина;
	КонецЕсли;
	
	Если ОбновитьТокен Тогда
		
		СтруктураАдреса = ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресСервиса());
		
		Соединение = СоединениеССервисом(СтруктураАдреса, ТаймаутСоединения(), УчетнаяЗапись.Идентификатор, УчетнаяЗапись.Секрет);
		Запрос = ЗапросКСервисуАвторизации();
		
		Попытка
			Ответ = Соединение.ВызватьHTTPМетод("POST", Запрос);
		Исключение
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			СообщениеОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
			ЗаписатьОшибкуСервисаВЖурналРегистрации(СообщениеОбОшибке);
		КонецПопытки;
		
		Если Ответ <> Неопределено Тогда
			ТекстОтвета = Ответ.ПолучитьТелоКакСтроку();
			Если Ответ.КодСостояния = 200 Тогда
				СтруктураОтвета = ЗначениеИзJSON(ТекстОтвета, Ложь);
			Иначе
				СообщениеОбОшибке = СтрШаблон("%1; %2", Ответ.КодСостояния, ТекстОтвета);
				ЗаписатьОшибкуСервисаВЖурналРегистрации(СообщениеОбОшибке);
			КонецЕсли;
		КонецЕсли;
		
		Если ТипЗнч(СтруктураОтвета) = Тип("Структура") И СтруктураОтвета.Свойство(КлючВременногоТокена(), ВременныйТокен) Тогда
			УстановитьПривилегированныйРежим(Истина);
			РегистрыСведений.БезопасноеХранилищеДанныхОбщее.Записать(КлючЗаписиБезопасногоХранилища.Владелец, ВременныйТокен, КлючВременногоТокена());
			УстановитьПривилегированныйРежим(Ложь);
		КонецЕсли;
		
	КонецЕсли;
	
	РазблокироватьВременныйТокен(КлючЗаписиБезопасногоХранилища);
	
	Возврат ВременныйТокен;
	
КонецФункции

// Ключ токена в ответе сериса авторизации,
// он же - ключ значения в безопасном хранилизе данных
//
Функция КлючВременногоТокена()
	
	Возврат "id_token";
	
КонецФункции

Функция ЗапросКСервисуАвторизации()
	
	Запрос = Новый HTTPЗапрос;
	Запрос.АдресРесурса = АдресРесурсаСервисаАвторизации();
	Запрос.Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Запрос.УстановитьТелоИзСтроки("grant_type=client_credentials");
	
	Возврат Запрос;
	
КонецФункции

Функция АдресРесурсаСервисаАвторизации()
	
	Возврат "/auth/oidc/token";
	
КонецФункции

// Возвращает данные учетной записи.
// Используется для получения временного токена авторизации.
//
// Возвращаемое значение:
//   Структура, Неопределено
//     * Идентификатор - Строка
//     * Секрет - Строка
//
Функция УчетнаяЗаписьКлиента()
	
	УстановитьПривилегированныйРежим(Истина);
	УчетнаяЗапись = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(ВладелецДанныхБезопасногоХранилища(), "Идентификатор, Секрет", Истина);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если ТипЗнч(УчетнаяЗапись) <> Тип("Структура") Или Не ЗначениеЗаполнено(УчетнаяЗапись.Идентификатор) Тогда
		УчетнаяЗапись = Неопределено;
	КонецЕсли;
	
	Возврат УчетнаяЗапись;
	
КонецФункции

// Определяет действует ли токен по его описанию.
//
// Параметры:
//   Токен - Строка - JWT-токен
//   Чувствительность - Число - время, необходимое для гарантированного выполнения запроса с предъявлением токена.
//
// Возвращаемое значение:
//   Булево
//
Функция ТокенДейсвует(Токен, Чувствительность = 0)
	Перем СрокДействияUnixTime;
	
	СвойстваВременногоТокена = СвойстваТокена(Токен);
	
	Если СвойстваВременногоТокена.Свойство("exp", СрокДействияUnixTime) Тогда
		СрокДействия = ДатаИзUnixTime(СрокДействияUnixTime);
	КонецЕсли;
	
	Возврат СрокДействия <> Неопределено И СрокДействия > (ТекущаяДата() - Чувствительность);
	
КонецФункции

Функция ДатаИзUnixTime(UnixTime)
	
	Возврат МестноеВремя(Дата(1970, 1, 1) + UnixTime);
	
КонецФункции

// Возвращает свойства JWT-токена в стуктуре
//
// Параметры:
//   Токен - Строка - JWT-токен
//
// Возвращаемое значение:
//   Структура - header + payload в соответствии с RFC 7519 (https://tools.ietf.org/html/rfc7519)
//
Функция СвойстваТокена(Токен)
	
	Если Токен = Неопределено Тогда
		Возврат Новый Структура;
	КонецЕсли;
	
	РазделительЧастейТокена = ".";
	ЧастиТокена = СтрРазделить(СокрЛП(Токен), РазделительЧастейТокена);
	
	Если ЧастиТокена.Количество() = 3 Тогда
		
		// Токен JWT состоит из трех частей: заголовок (header), полезная нагрузка (payload) и подпись или данные шифрования
		
		ДвоичныеДанныеЗаголовка = Base64Значение(ДополнитьBase64Строку(ЧастиТокена[0]));
		ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанныеЗаголовка);
		СтрокаЗаголовка = ЧтениеДанных.ПрочитатьСтроку();
		ЧтениеДанных.Закрыть();
		
		ДвоичныеДанныеНагрузки = Base64Значение(ДополнитьBase64Строку(ЧастиТокена[1]));
		ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанныеНагрузки);
		СтрокаНагрузки = ЧтениеДанных.ПрочитатьСтроку();
		ЧтениеДанных.Закрыть();
		
	КонецЕсли;
	
	СвойстваВременногоТокена = Новый Структура;
	
	Если ЗначениеЗаполнено(СтрокаЗаголовка) Тогда
		СтруктураЗаголовка = ЗначениеИзJSON(СтрокаЗаголовка, Ложь);
		Если ЗначениеЗаполнено(СтруктураЗаголовка) И ТипЗнч(СтруктураЗаголовка) = Тип("Структура") Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(СвойстваВременногоТокена, СтруктураЗаголовка);
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СтрокаНагрузки) Тогда
		СтруктураНагрузки = ЗначениеИзJSON(СтрокаНагрузки, Ложь);
		Если ЗначениеЗаполнено(СтруктураНагрузки) И ТипЗнч(СтруктураНагрузки) = Тип("Структура") Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(СвойстваВременногоТокена, СтруктураНагрузки);
		КонецЕсли;
	КонецЕсли;
	
	Возврат СвойстваВременногоТокена;
	
КонецФункции

Функция ДополнитьBase64Строку(Base64Строка)
	
	ДлинаХвоста = 4 - (СтрДлина(Base64Строка) % 4);
	Если ДлинаХвоста > 0 Тогда
		Возврат СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Base64Строка, СтрДлина(Base64Строка) + ДлинаХвоста, "=", "Справа");
	Иначе
		Возврат Base64Строка;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область БлокировкаБезопасногоХранилищаВременногоТокена

Функция ЗаблокироватьВременныйТокенДляОбновления(КлючЗаписиБезопасногоХранилища)
	
	ДанныеЗаблокированы = Ложь;
	
	Для НомерПопытки = 1 По КоличествоПовторовОбновленияВременногоТокена() Цикл
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(КлючЗаписиБезопасногоХранилища);
			ДанныеЗаблокированы = Истина;
			Прервать;
		Исключение
			ЗаписьЖурналаРегистрации(ИмяСобытияЖурналаРегистрацииСервис(),
				УровеньЖурналаРегистрации.Информация,
				,
				,
				НСтр("ru = 'Ожидание блокировки безопасного хранилища временного токена'"));
		КонецПопытки;
		
		// Возможно другой сеанс уже обновляет временный токен.
		// Ждем возможности заблокировать, после чего снова проверим срок действия токена.
		ОбщегоНазначенияБТС.Пауза(ВремяОжиданияОбновленияВременногоТокена());
		
	КонецЦикла;
	
	Возврат ДанныеЗаблокированы;
	
КонецФункции

Процедура РазблокироватьВременныйТокен(КлючЗаписиБезопасногоХранилища)
	
	РазблокироватьДанныеДляРедактирования(КлючЗаписиБезопасногоХранилища);
	
КонецПроцедуры

Функция КоличествоПовторовОбновленияВременногоТокена()
	
	Возврат 6;
	
КонецФункции

Функция ВремяОжиданияОбновленияВременногоТокена()
	
	Возврат 20; // секунд
	
КонецФункции

#КонецОбласти

#КонецОбласти

